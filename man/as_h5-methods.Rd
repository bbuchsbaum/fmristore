% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_generic.R, R/io_h5_generic.R
\name{as_h5}
\alias{as_h5}
\alias{as_h5,NeuroVec-method}
\alias{as_h5,LatentNeuroVec-method}
\alias{as_h5,LabeledVolumeSet-method}
\alias{as_h5,list-method}
\alias{as_h5,NeuroVecSeq-method}
\title{Generic function to convert R objects to HDF5 format}
\usage{
as_h5(object, file, ...)

\S4method{as_h5}{NeuroVec}(
  object,
  file = NULL,
  data_type = "FLOAT",
  chunk_dim = c(4, 4, 4, dim(object)[4]),
  compression = 6
)

\S4method{as_h5}{LatentNeuroVec}(object, file = NULL, data_type = "FLOAT", compression = 6)

\S4method{as_h5}{LabeledVolumeSet}(
  object,
  file,
  mask,
  labels,
  compression = 4,
  dtype = hdf5r::h5types$H5T_NATIVE_DOUBLE,
  chunk_size = 1024,
  header_values = list()
)

\S4method{as_h5}{list}(
  object,
  file,
  scan_names,
  mask,
  clusters,
  scan_metadata,
  cluster_metadata = NULL,
  summary_only = FALSE,
  compression = 4,
  chunk_size = 1024
)

\S4method{as_h5}{NeuroVecSeq}(object, file = NULL, ...)
}
\arguments{
\item{object}{The R object to convert to HDF5 (e.g., a \code{NeuroVol} or \code{NeuroVec}).}

\item{file}{The path to the HDF5 file to create or modify.}

\item{...}{Additional arguments specific to the particular method (see Details).}

\item{data_type}{For NeuroVec/LatentNeuroVec methods: Storage type (e.g., "FLOAT"). 
Default "FLOAT"}

\item{chunk_dim}{For NeuroVec method: Chunk dimensions. Default depends on input dimensions}

\item{compression}{For all methods: Integer compression level [0..9]. Default varies by method}

\item{mask}{For LabeledVolumeSet method: The mask to use (LogicalNeuroVol)}

\item{labels}{For LabeledVolumeSet method: Character vector of labels}

\item{dtype}{For LabeledVolumeSet method: HDF5 data type for values. Default H5T_NATIVE_DOUBLE}

\item{chunk_size}{For LabeledVolumeSet/list methods: Integer chunk size for HDF5. Default 1024}

\item{header_values}{For LabeledVolumeSet method: List of additional header values}

\item{scan_names}{For list method: Character vector of scan names}

\item{clusters}{For list method: ClusteredNeuroVol with cluster IDs}

\item{scan_metadata}{For list method: List of metadata lists, one per scan}

\item{cluster_metadata}{For list method: Optional data.frame with cluster descriptions}

\item{summary_only}{For list method: If TRUE, save summary data only}
}
\value{
An object representing the HDF5 storage, typically of a class
  corresponding to the input type (e.g., \code{H5NeuroVol} for \code{NeuroVol} input,
  \code{H5NeuroVec} for \code{NeuroVec} input).
}
\description{
A generic function for converting various types of R objects to HDF5 format,
providing a standardized interface for serialization to HDF5.
}
\section{Methods}{

\describe{
  \item{\code{signature(object = "NeuroVec")}}{
    Creates an HDF5 file from a 4D NeuroVec object.
    Additional parameters:
    \describe{
      \item{\code{data_type}}{Storage type (e.g., "FLOAT"). Default "FLOAT"}
      \item{\code{chunk_dim}}{Chunk dimensions. Default depends on input dimensions}
      \item{\code{compression}}{Integer [0..9], default 6}
    }
    Returns an H5NeuroVec referencing the new HDF5 file.
  }
  \item{\code{signature(object = "LatentNeuroVec")}}{
    Saves a LatentNeuroVec to an HDF5 file in BasisEmbeddingSpec format.
    Additional parameters:
    \describe{
      \item{\code{data_type}}{Storage type (e.g., "FLOAT"). Default "FLOAT"}
      \item{\code{compression}}{Integer [1..9], default 6}
    }
    Returns an HDF5 file object.
  }
  \item{\code{signature(object = "LabeledVolume")}}{
    Saves a LabeledVolume to an HDF5 file.
    Additional parameters:
    \describe{
      \item{\code{mask}}{The mask to use (LogicalNeuroVol)}
      \item{\code{labels}}{Character vector of labels}
      \item{\code{compression}}{Integer [0..9], default 4}
      \item{\code{dtype}}{HDF5 data type for values. Default H5T_NATIVE_DOUBLE}
      \item{\code{chunk_size}}{Integer chunk size for HDF5, default 1024}
      \item{\code{header_values}}{List of additional header values}
    }
    Returns an HDF5 file object.
  }
  \item{\code{signature(object = "list")}}{
    Writes a cluster-based time-series dataset to an HDF5 file.
    Additional parameters:
    \describe{
      \item{\code{scan_names}}{Character vector of scan names}
      \item{\code{mask}}{LogicalNeuroVol for 3D geometry}
      \item{\code{clusters}}{ClusteredNeuroVol with cluster IDs}
      \item{\code{scan_metadata}}{List of metadata lists, one per scan}
      \item{\code{cluster_metadata}}{Optional data.frame with cluster descriptions}
      \item{\code{summary_only}}{Logical; if TRUE, store only summary data}
      \item{\code{compression}}{Integer [0..9], default 4}
      \item{\code{chunk_size}}{Chunk dimension for 2D writes, default 1024}
    }
    Returns an HDF5-backed object representing the clustered dataset (e.g., H5ClusterExperiment).
  }
  \item{\code{signature(object = "NeuroVecSeq")}}{
    Writes a sequence of NeuroVec objects (multiple 4D scans) to a single HDF5 file.
    All NeuroVec objects must have the same spatial dimensions.
    Additional parameters:
    \describe{
      \item{\code{scan_names}}{Optional character vector of scan names. 
        If NULL, uses "scan_1", "scan_2", etc.}
      \item{\code{data_type}}{Character string: "FLOAT" (default), "DOUBLE", or "INT"}
      \item{\code{chunk_dim}}{Numeric vector specifying chunk sizes. 
        If NULL, uses time-optimized chunking}
      \item{\code{compression}}{Integer [0..9], default 6}
      \item{\code{scan_metadata}}{Optional named list of metadata lists, one per scan}
    }
    Returns the file path of the created HDF5 file.
  }
}
}

\examples{
\dontrun{
# Example 1: NeuroVec (DenseNeuroVec) to HDF5
# Ensure helper function is available and as_h5 exists
# if (!is.null(fmristore:::create_minimal_DenseNeuroVec) &&
#     exists("as_h5", where = "package:fmristore")) {

dvec <- fmristore:::create_minimal_DenseNeuroVec(dims = c(3L,3L,2L,4L))
temp_h5_file <- tempfile(fileext = ".h5")
h5_obj <- NULL

tryCatch({
    # Convert DenseNeuroVec to an HDF5 file and get an H5NeuroVec object back
    h5_obj <- as_h5(dvec, file = temp_h5_file,
                    data_type = "FLOAT",
                    chunk_dim = c(2, 2, 2, 4),
                    compression = 4)

    print(h5_obj) # Should be an H5NeuroVec

}, error = function(e) {
    message("as_h5 NeuroVec example failed: ", e$message)
}, finally = {
    if (!is.null(h5_obj)) try(close(h5_obj), silent = TRUE)
    if (file.exists(temp_h5_file)) {
      unlink(temp_h5_file)
    }
})
# }

# Example 2: LatentNeuroVec to HDF5
# if (!is.null(fmristore:::create_minimal_LatentNeuroVec) &&
#     exists("as_h5", where = "package:fmristore")) {

lnv <- fmristore:::create_minimal_LatentNeuroVec(
    space_dims = c(4L, 4L, 2L),
    n_time = 6L,
    n_comp = 2L
)
temp_h5_file_lnv <- tempfile(fileext = ".h5") # Use a different temp file name
h5_obj_lnv <- NULL # Use a different object name

tryCatch({
    # Convert LatentNeuroVec to HDF5
    h5_obj_lnv <- as_h5(lnv, file = temp_h5_file_lnv, compression = 4)

    # File should exist and h5_obj_lnv should be a valid H5File object
    if (file.exists(temp_h5_file_lnv)) {
      print("LatentNeuroVec HDF5 file created successfully: ", temp_h5_file_lnv)
    }

}, error = function(e) {
    message("as_h5 LatentNeuroVec example failed: ", e$message)
}, finally = {
    if (!is.null(h5_obj_lnv) && inherits(h5_obj_lnv, "H5File") && h5_obj_lnv$is_valid) {
      try(h5_obj_lnv$close_all(), silent = TRUE)
    }
    if (file.exists(temp_h5_file_lnv)) {
      unlink(temp_h5_file_lnv)
    }
})
# }

# Example 3: Clustered dataset (list) to HDF5
# (This requires more complex setup, so we use a simplified theoretical example)
\dontrun{
  # Removed: if (requireNamespace("neuroim2", quietly = TRUE) && ...

  # In practice, you would:
  # 1. Create a list of NeuroVec/DenseNeuroVec objects (scan data)
  # 2. Create a LogicalNeuroVol mask
  # 3. Create a ClusteredNeuroVol defining clusters
  # 4. Define scan names and metadata
  # 5. Call as_h5() with these components

  # Note: This example is simplified for documentation and won't execute
  # as the actual clustered dataset structure is more complex

  message("Example usage for clustered dataset (as_h5 for list method):")
  message("  # vecs_list <- ... list of NeuroVec objects ...")
  message("  # mask_obj <- fmristore:::create_minimal_LogicalNeuroVol(...)")
  message("  # clusters_obj <- fmristore:::create_minimal_ClusteredNeuroVol(...)")
  message("  # scan_meta <- list(list(TR=2), list(TR=2))")
  message("  # h5_clust_obj <- as_h5(vecs_list, file = tempfile(fileext=\".h5\"), ")
  message("  #                       scan_names = c('run1', 'run2'), ")
  message("  #                       mask = mask_obj, clusters = clusters_obj, ")
  message("  #                       scan_metadata = scan_meta)")
  message("  # print(h5_clust_obj)")
  message("  # if (!is.null(h5_clust_obj)) try(close(h5_clust_obj), silent=TRUE)")
  message("  # if (file.exists(attr(h5_clust_obj, \"filepath\"))) ")
  message("  #     unlink(attr(h5_clust_obj, \"filepath\"))")

}
}

}
